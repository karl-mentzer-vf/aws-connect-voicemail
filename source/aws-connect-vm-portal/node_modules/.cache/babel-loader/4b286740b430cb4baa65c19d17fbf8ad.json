{"ast":null,"code":"var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nvar __generator = this && this.__generator || function (thisArg, body) {\n  var _ = {\n      label: 0,\n      sent: function sent() {\n        if (t[0] & 1) throw t[1];\n        return t[1];\n      },\n      trys: [],\n      ops: []\n    },\n    f,\n    y,\n    t,\n    g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n    while (_) try {\n      if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n      if (y = 0, t) op = [op[0] & 2, t.value];\n      switch (op[0]) {\n        case 0:\n        case 1:\n          t = op;\n          break;\n        case 4:\n          _.label++;\n          return {\n            value: op[1],\n            done: false\n          };\n        case 5:\n          _.label++;\n          y = op[1];\n          op = [0];\n          continue;\n        case 7:\n          op = _.ops.pop();\n          _.trys.pop();\n          continue;\n        default:\n          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n            _ = 0;\n            continue;\n          }\n          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n            _.label = op[1];\n            break;\n          }\n          if (op[0] === 6 && _.label < t[1]) {\n            _.label = t[1];\n            t = op;\n            break;\n          }\n          if (t && _.label < t[2]) {\n            _.label = t[2];\n            _.ops.push(op);\n            break;\n          }\n          if (t[2]) _.ops.pop();\n          _.trys.pop();\n          continue;\n      }\n      op = body.call(thisArg, _);\n    } catch (e) {\n      op = [6, e];\n      y = 0;\n    } finally {\n      f = t = 0;\n    }\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n};\nimport { ConsoleLogger as Logger } from '@aws-amplify/core';\nimport { CONTROL_MSG as PUBSUB_CONTROL_MSG } from '@aws-amplify/pubsub';\nimport Observable from 'zen-observable-ts';\nimport { ModelPredicateCreator } from '../predicates';\nimport { SYNC } from '../util';\nimport DataStoreConnectivity from './datastoreConnectivity';\nimport { ModelMerger } from './merger';\nimport { MutationEventOutbox } from './outbox';\nimport { MutationProcessor } from './processors/mutation';\nimport { CONTROL_MSG, SubscriptionProcessor } from './processors/subscription';\nimport { SyncProcessor } from './processors/sync';\nimport { createMutationInstanceFromModelOperation, predicateToGraphQLCondition } from './utils';\nvar logger = new Logger('DataStore');\nvar ownSymbol = Symbol('sync');\nvar SyncEngine = /** @class */function () {\n  function SyncEngine(schema, namespaceResolver, modelClasses, userModelClasses, storage, modelInstanceCreator, maxRecordsToSync, syncPageSize, conflictHandler, errorHandler) {\n    this.schema = schema;\n    this.namespaceResolver = namespaceResolver;\n    this.modelClasses = modelClasses;\n    this.userModelClasses = userModelClasses;\n    this.storage = storage;\n    this.modelInstanceCreator = modelInstanceCreator;\n    this.maxRecordsToSync = maxRecordsToSync;\n    this.syncPageSize = syncPageSize;\n    this.started = false;\n    this.online = false;\n    this.processingMutations = false;\n    var MutationEvent = this.modelClasses['MutationEvent'];\n    this.outbox = new MutationEventOutbox(this.schema, this.namespaceResolver, MutationEvent, ownSymbol);\n    this.modelMerger = new ModelMerger(this.outbox, ownSymbol);\n    this.syncQueriesProcessor = new SyncProcessor(this.schema, maxRecordsToSync, syncPageSize);\n    this.subscriptionsProcessor = new SubscriptionProcessor(this.schema);\n    this.mutationsProcessor = new MutationProcessor(this.schema, this.storage, this.userModelClasses, this.outbox, this.modelInstanceCreator, MutationEvent, conflictHandler, errorHandler);\n  }\n  SyncEngine.prototype.start = function (params) {\n    var _this = this;\n    return new Observable(function (observer) {\n      logger.log('starting sync engine...');\n      _this.started = true;\n      var subscriptions = [];\n      (function () {\n        return __awaiter(_this, void 0, void 0, function () {\n          var err_1, datastoreConnectivity;\n          var _this = this;\n          return __generator(this, function (_a) {\n            switch (_a.label) {\n              case 0:\n                _a.trys.push([0, 2,, 3]);\n                return [4 /*yield*/, this.setupModels(params)];\n              case 1:\n                _a.sent();\n                return [3 /*break*/, 3];\n              case 2:\n                err_1 = _a.sent();\n                logger.error('Sync engine error on start', err_1);\n                return [2 /*return*/];\n              case 3:\n                datastoreConnectivity = new DataStoreConnectivity();\n                datastoreConnectivity.status().subscribe(function (_a) {\n                  var online = _a.online;\n                  return __awaiter(_this, void 0, void 0, function () {\n                    var _b, ctlSubsObservable, dataSubsObservable, errorHandler, _c, _d, err_2, currentTimeStamp, modelLastSync, paginatingModels, syncQueriesObservable, syncQuerySubscription, err_3;\n                    var _this = this;\n                    return __generator(this, function (_e) {\n                      switch (_e.label) {\n                        case 0:\n                          if (!(online && !this.online)) return [3 /*break*/, 10];\n                          _b = this.subscriptionsProcessor.start(), ctlSubsObservable = _b[0], dataSubsObservable = _b[1];\n                          errorHandler = this.disconnectionHandler(datastoreConnectivity);\n                          _e.label = 1;\n                        case 1:\n                          _e.trys.push([1, 3,, 4]);\n                          _d = (_c = subscriptions).push;\n                          return [4 /*yield*/, this.waitForSubscriptionsReady(ctlSubsObservable, errorHandler)];\n                        case 2:\n                          _d.apply(_c, [_e.sent()]);\n                          return [3 /*break*/, 4];\n                        case 3:\n                          err_2 = _e.sent();\n                          observer.error(err_2);\n                          return [2 /*return*/];\n                        case 4:\n                          logger.log('Realtime ready');\n                          currentTimeStamp = new Date().getTime();\n                          return [4 /*yield*/, this.getModelsMetadataWithNextFullSync(currentTimeStamp)];\n                        case 5:\n                          modelLastSync = _e.sent();\n                          paginatingModels = new Set(modelLastSync.keys());\n                          syncQueriesObservable = this.syncQueriesProcessor.start(modelLastSync);\n                          if (this.isFullSync(modelLastSync)) {\n                            clearTimeout(this.fullSyncTimeoutId);\n                            this.fullSyncTimeoutId = undefined;\n                          }\n                          _e.label = 6;\n                        case 6:\n                          _e.trys.push([6, 8,, 9]);\n                          return [4 /*yield*/, this.waitForSyncQueries(syncQueriesObservable, paginatingModels)];\n                        case 7:\n                          syncQuerySubscription = _e.sent();\n                          if (syncQuerySubscription) {\n                            subscriptions.push(syncQuerySubscription);\n                          }\n                          return [3 /*break*/, 9];\n                        case 8:\n                          err_3 = _e.sent();\n                          observer.error(err_3);\n                          return [2 /*return*/];\n                        case 9:\n                          //#endregion\n                          //#region process mutations\n                          subscriptions.push(this.mutationsProcessor.start().subscribe(function (_a) {\n                            var _transformerMutationType = _a[0],\n                              modelDefinition = _a[1],\n                              item = _a[2];\n                            var modelConstructor = _this.userModelClasses[modelDefinition.name];\n                            var model = _this.modelInstanceCreator(modelConstructor, item);\n                            _this.modelMerger.merge(_this.storage, model);\n                          }));\n                          //#endregion\n                          // TODO: extract to function\n                          subscriptions.push(dataSubsObservable.subscribe(function (_a) {\n                            var _transformerMutationType = _a[0],\n                              modelDefinition = _a[1],\n                              item = _a[2];\n                            var modelConstructor = _this.userModelClasses[modelDefinition.name];\n                            var model = _this.modelInstanceCreator(modelConstructor, item);\n                            _this.modelMerger.merge(_this.storage, model);\n                          }));\n                          return [3 /*break*/, 11];\n                        case 10:\n                          if (!online) {\n                            subscriptions.forEach(function (sub) {\n                              return sub.unsubscribe();\n                            });\n                            subscriptions = [];\n                          }\n                          _e.label = 11;\n                        case 11:\n                          this.online = online;\n                          return [2 /*return*/];\n                      }\n                    });\n                  });\n                });\n\n                this.storage.observe(null, null, ownSymbol).filter(function (_a) {\n                  var model = _a.model;\n                  var modelDefinition = _this.getModelDefinition(model);\n                  return modelDefinition.syncable === true;\n                }).subscribe({\n                  next: function next(_a) {\n                    var opType = _a.opType,\n                      model = _a.model,\n                      element = _a.element,\n                      condition = _a.condition;\n                    return __awaiter(_this, void 0, void 0, function () {\n                      var namespace, MutationEventConstructor, graphQLCondition, mutationEvent;\n                      return __generator(this, function (_b) {\n                        switch (_b.label) {\n                          case 0:\n                            namespace = this.schema.namespaces[this.namespaceResolver(model)];\n                            MutationEventConstructor = this.modelClasses['MutationEvent'];\n                            graphQLCondition = predicateToGraphQLCondition(condition);\n                            mutationEvent = createMutationInstanceFromModelOperation(namespace.relationships, this.getModelDefinition(model), opType, model, element, graphQLCondition, MutationEventConstructor, this.modelInstanceCreator);\n                            return [4 /*yield*/, this.outbox.enqueue(this.storage, mutationEvent)];\n                          case 1:\n                            _b.sent();\n                            if (this.online) {\n                              this.mutationsProcessor.resume();\n                            }\n                            return [2 /*return*/];\n                        }\n                      });\n                    });\n                  }\n                });\n\n                return [2 /*return*/];\n            }\n          });\n        });\n      })();\n\n      return function () {\n        subscriptions.forEach(function (sub) {\n          return sub.unsubscribe();\n        });\n      };\n    });\n  };\n  SyncEngine.prototype.getModelsMetadataWithNextFullSync = function (currentTimeStamp) {\n    return __awaiter(this, void 0, void 0, function () {\n      var modelLastSync, _a;\n      var _this = this;\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            _a = Map.bind;\n            return [4 /*yield*/, this.getModelsMetadata()];\n          case 1:\n            modelLastSync = new (_a.apply(Map, [void 0, _b.sent().map(function (_a) {\n              var namespace = _a.namespace,\n                model = _a.model,\n                lastSync = _a.lastSync,\n                lastFullSync = _a.lastFullSync,\n                fullSyncInterval = _a.fullSyncInterval;\n              var nextFullSync = lastFullSync + fullSyncInterval;\n              var syncFrom = !lastFullSync || nextFullSync < currentTimeStamp ? 0 // perform full sync if expired\n              : lastSync; // perform delta sync\n              return [_this.schema.namespaces[namespace].models[model], [namespace, syncFrom]];\n            })]))();\n            return [2 /*return*/, modelLastSync];\n        }\n      });\n    });\n  };\n  SyncEngine.prototype.isFullSync = function (modelsMap) {\n    for (var _i = 0, _a = Array.from(modelsMap.values()); _i < _a.length; _i++) {\n      var _b = _a[_i],\n        syncFrom = _b[1];\n      if (syncFrom === 0) {\n        return true;\n      }\n    }\n    return false;\n  };\n  SyncEngine.prototype.waitForSyncQueries = function (observable, paginatingModels) {\n    return __awaiter(this, void 0, void 0, function () {\n      var _this = this;\n      return __generator(this, function (_a) {\n        return [2 /*return*/, new Promise(function (resolve, reject) {\n          if (!_this.online) {\n            resolve();\n          }\n          var currentTimeStamp = new Date().getTime();\n          var subscription = observable.subscribe({\n            error: function error(err) {\n              reject(err);\n            },\n            next: function next(_a) {\n              var namespace = _a.namespace,\n                modelDefinition = _a.modelDefinition,\n                items = _a.items,\n                done = _a.done,\n                startedAt = _a.startedAt,\n                isFullSync = _a.isFullSync;\n              return __awaiter(_this, void 0, void 0, function () {\n                var promises, modelMetadata_1, fullSyncInterval;\n                var _this = this;\n                return __generator(this, function (_b) {\n                  switch (_b.label) {\n                    case 0:\n                      promises = items.map(function (item) {\n                        return __awaiter(_this, void 0, void 0, function () {\n                          var modelConstructor, model;\n                          return __generator(this, function (_a) {\n                            modelConstructor = this.userModelClasses[modelDefinition.name];\n                            model = this.modelInstanceCreator(modelConstructor, item);\n                            return [2 /*return*/, this.modelMerger.merge(this.storage, model)];\n                          });\n                        });\n                      });\n                      return [4 /*yield*/, Promise.all(promises)];\n                    case 1:\n                      _b.sent();\n                      if (!done) return [3 /*break*/, 4];\n                      paginatingModels.delete(modelDefinition);\n                      return [4 /*yield*/, this.getModelMetadata(namespace, modelDefinition.name)];\n                    case 2:\n                      modelMetadata_1 = _b.sent();\n                      modelMetadata_1 = this.modelClasses.ModelMetadata.copyOf(modelMetadata_1, function (draft) {\n                        draft.lastSync = startedAt;\n                        draft.lastFullSync = isFullSync ? currentTimeStamp : modelMetadata_1.lastFullSync;\n                      });\n                      fullSyncInterval = modelMetadata_1.fullSyncInterval;\n                      return [4 /*yield*/, this.storage.save(modelMetadata_1, undefined, ownSymbol)];\n                    case 3:\n                      _b.sent();\n                      // resolve promise if all done\n                      if (paginatingModels.size === 0) {\n                        resolve(subscription);\n                      }\n                      if (isFullSync && !this.fullSyncTimeoutId) {\n                        // register next full sync when no full sync is already scheduled\n                        this.fullSyncTimeoutId = setTimeout(function () {\n                          return __awaiter(_this, void 0, void 0, function () {\n                            var currentTimeStamp, modelLastSync, paginatingModels, syncQueriesObservable;\n                            return __generator(this, function (_a) {\n                              switch (_a.label) {\n                                case 0:\n                                  currentTimeStamp = new Date().getTime();\n                                  return [4 /*yield*/, this.getModelsMetadataWithNextFullSync(currentTimeStamp)];\n                                case 1:\n                                  modelLastSync = _a.sent();\n                                  paginatingModels = new Set(modelLastSync.keys());\n                                  syncQueriesObservable = this.syncQueriesProcessor.start(modelLastSync);\n                                  this.fullSyncTimeoutId = undefined;\n                                  this.waitForSyncQueries(syncQueriesObservable, paginatingModels);\n                                  return [2 /*return*/];\n                              }\n                            });\n                          });\n                        }, fullSyncInterval);\n                      }\n                      _b.label = 4;\n                    case 4:\n                      return [2 /*return*/];\n                  }\n                });\n              });\n            }\n          });\n        })];\n      });\n    });\n  };\n\n  SyncEngine.prototype.disconnectionHandler = function (datastoreConnectivity) {\n    return function (msg) {\n      // This implementation is tight to AWSAppSyncRealTimeProvider 'Connection closed', 'Timeout disconnect' msg\n      if (PUBSUB_CONTROL_MSG.CONNECTION_CLOSED === msg || PUBSUB_CONTROL_MSG.TIMEOUT_DISCONNECT === msg) {\n        datastoreConnectivity.socketDisconnected();\n      }\n    };\n  };\n  SyncEngine.prototype.waitForSubscriptionsReady = function (ctlSubsObservable, errorHandler) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        return [2 /*return*/, new Promise(function (resolve, reject) {\n          var subscription = ctlSubsObservable.subscribe({\n            next: function next(msg) {\n              if (msg === CONTROL_MSG.CONNECTED) {\n                resolve(subscription);\n              }\n            },\n            error: function error(err) {\n              reject(\"subscription failed \" + err);\n              errorHandler(err);\n            }\n          });\n        })];\n      });\n    });\n  };\n  SyncEngine.prototype.setupModels = function (params) {\n    return __awaiter(this, void 0, void 0, function () {\n      var fullSyncInterval, ModelMetadata, models, promises;\n      var _this = this;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            fullSyncInterval = params.fullSyncInterval;\n            ModelMetadata = this.modelClasses.ModelMetadata;\n            models = [];\n            Object.values(this.schema.namespaces).forEach(function (namespace) {\n              Object.values(namespace.models).filter(function (_a) {\n                var syncable = _a.syncable;\n                return syncable;\n              }).forEach(function (model) {\n                models.push([namespace.name, model.name]);\n              });\n            });\n            promises = models.map(function (_a) {\n              var namespace = _a[0],\n                model = _a[1];\n              return __awaiter(_this, void 0, void 0, function () {\n                var modelMetadata;\n                return __generator(this, function (_b) {\n                  switch (_b.label) {\n                    case 0:\n                      return [4 /*yield*/, this.getModelMetadata(namespace, model)];\n                    case 1:\n                      modelMetadata = _b.sent();\n                      if (!(modelMetadata === undefined)) return [3 /*break*/, 3];\n                      return [4 /*yield*/, this.storage.save(this.modelInstanceCreator(ModelMetadata, {\n                        model: model,\n                        namespace: namespace,\n                        lastSync: null,\n                        fullSyncInterval: fullSyncInterval,\n                        lastFullSync: null\n                      }), undefined, ownSymbol)];\n                    case 2:\n                      _b.sent();\n                      return [3 /*break*/, 5];\n                    case 3:\n                      return [4 /*yield*/, this.storage.save(this.modelClasses.ModelMetadata.copyOf(modelMetadata, function (draft) {\n                        draft.fullSyncInterval = fullSyncInterval;\n                      }))];\n                    case 4:\n                      _b.sent();\n                      _b.label = 5;\n                    case 5:\n                      return [2 /*return*/];\n                  }\n                });\n              });\n            });\n\n            return [4 /*yield*/, Promise.all(promises)];\n          case 1:\n            _a.sent();\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n\n  SyncEngine.prototype.getModelsMetadata = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var ModelMetadata, modelsMetadata;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            ModelMetadata = this.modelClasses.ModelMetadata;\n            return [4 /*yield*/, this.storage.query(ModelMetadata)];\n          case 1:\n            modelsMetadata = _a.sent();\n            return [2 /*return*/, modelsMetadata];\n        }\n      });\n    });\n  };\n  SyncEngine.prototype.getModelMetadata = function (namespace, model) {\n    return __awaiter(this, void 0, void 0, function () {\n      var ModelMetadata, predicate, modelMetadata;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            ModelMetadata = this.modelClasses.ModelMetadata;\n            predicate = ModelPredicateCreator.createFromExisting(this.schema.namespaces[SYNC].models[ModelMetadata.name], function (c) {\n              return c.namespace('eq', namespace).model('eq', model);\n            });\n            return [4 /*yield*/, this.storage.query(ModelMetadata, predicate)];\n          case 1:\n            modelMetadata = _a.sent()[0];\n            return [2 /*return*/, modelMetadata];\n        }\n      });\n    });\n  };\n  SyncEngine.prototype.getModelDefinition = function (modelConstructor) {\n    var namespaceName = this.namespaceResolver(modelConstructor);\n    var modelDefinition = this.schema.namespaces[namespaceName].models[modelConstructor.name];\n    return modelDefinition;\n  };\n  SyncEngine.getNamespace = function () {\n    var namespace = {\n      name: SYNC,\n      relationships: {},\n      enums: {\n        OperationType: {\n          name: 'OperationType',\n          values: ['CREATE', 'UPDATE', 'DELETE']\n        }\n      },\n      nonModels: {},\n      models: {\n        MutationEvent: {\n          name: 'MutationEvent',\n          pluralName: 'MutationEvents',\n          syncable: false,\n          fields: {\n            id: {\n              name: 'id',\n              type: 'ID',\n              isRequired: true,\n              isArray: false\n            },\n            model: {\n              name: 'model',\n              type: 'String',\n              isRequired: true,\n              isArray: false\n            },\n            data: {\n              name: 'data',\n              type: 'String',\n              isRequired: true,\n              isArray: false\n            },\n            modelId: {\n              name: 'modelId',\n              type: 'String',\n              isRequired: true,\n              isArray: false\n            },\n            operation: {\n              name: 'operation',\n              type: {\n                enum: 'Operationtype'\n              },\n              isArray: false,\n              isRequired: true\n            },\n            condition: {\n              name: 'condition',\n              type: 'String',\n              isArray: false,\n              isRequired: true\n            }\n          }\n        },\n        ModelMetadata: {\n          name: 'ModelMetadata',\n          pluralName: 'ModelsMetadata',\n          syncable: false,\n          fields: {\n            id: {\n              name: 'id',\n              type: 'ID',\n              isRequired: true,\n              isArray: false\n            },\n            namespace: {\n              name: 'namespace',\n              type: 'String',\n              isRequired: true,\n              isArray: false\n            },\n            model: {\n              name: 'model',\n              type: 'String',\n              isRequired: true,\n              isArray: false\n            },\n            lastSync: {\n              name: 'lastSync',\n              type: 'Int',\n              isRequired: false,\n              isArray: false\n            },\n            lastFullSync: {\n              name: 'lastFullSync',\n              type: 'Int',\n              isRequired: false,\n              isArray: false\n            },\n            fullSyncInterval: {\n              name: 'fullSyncInterval',\n              type: 'Int',\n              isRequired: true,\n              isArray: false\n            }\n          }\n        }\n      }\n    };\n    return namespace;\n  };\n  return SyncEngine;\n}();\nexport { SyncEngine };","map":null,"metadata":{},"sourceType":"module"}