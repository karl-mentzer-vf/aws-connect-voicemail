{"ast":null,"code":"var __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n    return t;\n  };\n  return __assign.apply(this, arguments);\n};\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nvar __generator = this && this.__generator || function (thisArg, body) {\n  var _ = {\n      label: 0,\n      sent: function () {\n        if (t[0] & 1) throw t[1];\n        return t[1];\n      },\n      trys: [],\n      ops: []\n    },\n    f,\n    y,\n    t,\n    g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n    while (_) try {\n      if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n      if (y = 0, t) op = [op[0] & 2, t.value];\n      switch (op[0]) {\n        case 0:\n        case 1:\n          t = op;\n          break;\n        case 4:\n          _.label++;\n          return {\n            value: op[1],\n            done: false\n          };\n        case 5:\n          _.label++;\n          y = op[1];\n          op = [0];\n          continue;\n        case 7:\n          op = _.ops.pop();\n          _.trys.pop();\n          continue;\n        default:\n          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n            _ = 0;\n            continue;\n          }\n          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n            _.label = op[1];\n            break;\n          }\n          if (op[0] === 6 && _.label < t[1]) {\n            _.label = t[1];\n            t = op;\n            break;\n          }\n          if (t && _.label < t[2]) {\n            _.label = t[2];\n            _.ops.push(op);\n            break;\n          }\n          if (t[2]) _.ops.pop();\n          _.trys.pop();\n          continue;\n      }\n      op = body.call(thisArg, _);\n    } catch (e) {\n      op = [6, e];\n      y = 0;\n    } finally {\n      f = t = 0;\n    }\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n};\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\nimport { ConsoleLogger as Logger } from '@aws-amplify/core';\nimport { immerable, produce, setAutoFreeze } from 'immer';\nimport { v1 as uuid1, v4 as uuid4 } from 'uuid';\nimport Observable from 'zen-observable-ts';\nimport { isPredicatesAll, ModelPredicateCreator } from '../predicates';\nimport Storage from '../storage/storage';\nimport { SyncEngine } from '../sync';\nimport { GraphQLScalarType, isGraphQLScalarType } from '../types';\nimport { DATASTORE, establishRelation, exhaustiveCheck, isModelConstructor, STORAGE, SYNC, USER } from '../util';\nsetAutoFreeze(true);\nvar logger = new Logger('DataStore');\nvar SETTING_SCHEMA_VERSION = 'schemaVersion';\nvar storage;\nvar schema;\nvar modelNamespaceMap = new WeakMap();\nvar getModelDefinition = function (modelConstructor) {\n  var namespace = modelNamespaceMap.get(modelConstructor);\n  return schema.namespaces[namespace].models[modelConstructor.name];\n};\nvar isValidModelConstructor = function (obj) {\n  return isModelConstructor(obj) && modelNamespaceMap.has(obj);\n};\nvar namespaceResolver = function (modelConstructor) {\n  return modelNamespaceMap.get(modelConstructor);\n};\nvar dataStoreClasses;\nvar userClasses;\nvar syncClasses;\nvar storageClasses;\nvar initSchema = function (userSchema) {\n  var _a;\n  if (schema !== undefined) {\n    throw new Error('The schema has already been initialized');\n  }\n  logger.log('validating schema', {\n    schema: userSchema\n  });\n  var internalUserNamespace = __assign({\n    name: USER\n  }, userSchema);\n  logger.log('DataStore', 'Init models');\n  userClasses = createTypeClasses(internalUserNamespace);\n  logger.log('DataStore', 'Models initialized');\n  var dataStoreNamespace = getNamespace();\n  var storageNamespace = Storage.getNamespace();\n  var syncNamespace = SyncEngine.getNamespace();\n  dataStoreClasses = createTypeClasses(dataStoreNamespace);\n  storageClasses = createTypeClasses(storageNamespace);\n  syncClasses = createTypeClasses(syncNamespace);\n  schema = {\n    namespaces: (_a = {}, _a[dataStoreNamespace.name] = dataStoreNamespace, _a[internalUserNamespace.name] = internalUserNamespace, _a[storageNamespace.name] = storageNamespace, _a[syncNamespace.name] = syncNamespace, _a),\n    version: userSchema.version\n  };\n  Object.keys(schema.namespaces).forEach(function (namespace) {\n    schema.namespaces[namespace].relationships = establishRelation(schema.namespaces[namespace]);\n    var modelAssociations = new Map();\n    Object.values(schema.namespaces[namespace].models).forEach(function (model) {\n      var wea = [];\n      Object.values(model.fields).filter(function (field) {\n        return field.association && field.association.connectionType === 'BELONGS_TO' && field.type.model !== model.name;\n      }).forEach(function (field) {\n        return wea.push(field.type.model);\n      });\n      modelAssociations.set(model.name, wea);\n    });\n    var result = new Map();\n    var count = 1000;\n    while (true && count > 0) {\n      if (modelAssociations.size === 0) {\n        break;\n      }\n      count--;\n      if (count === 0) {\n        throw new Error('Models are not topologically sortable. Please verify your schema.');\n      }\n      for (var _i = 0, _a = Array.from(modelAssociations.keys()); _i < _a.length; _i++) {\n        var modelName = _a[_i];\n        var parents = modelAssociations.get(modelName);\n        if (parents.every(function (x) {\n          return result.has(x);\n        })) {\n          result.set(modelName, parents);\n        }\n      }\n      Array.from(result.keys()).forEach(function (x) {\n        return modelAssociations.delete(x);\n      });\n    }\n    schema.namespaces[namespace].modelTopologicalOrdering = result;\n  });\n  return userClasses;\n};\nvar createTypeClasses = function (namespace) {\n  var classes = {};\n  Object.entries(namespace.models).forEach(function (_a) {\n    var modelName = _a[0],\n      modelDefinition = _a[1];\n    var clazz = createModelClass(modelDefinition);\n    classes[modelName] = clazz;\n    modelNamespaceMap.set(clazz, namespace.name);\n  });\n  Object.entries(namespace.nonModels || {}).forEach(function (_a) {\n    var typeName = _a[0],\n      typeDefinition = _a[1];\n    var clazz = createNonModelClass(typeDefinition);\n    classes[typeName] = clazz;\n  });\n  return classes;\n};\nvar instancesMetadata = new WeakSet();\nfunction modelInstanceCreator(modelConstructor, init) {\n  instancesMetadata.add(init);\n  return new modelConstructor(init);\n}\nvar initializeInstance = function (init, modelDefinition, draft) {\n  Object.entries(init).forEach(function (_a) {\n    var k = _a[0],\n      v = _a[1];\n    var fieldDefinition = modelDefinition.fields[k];\n    if (fieldDefinition !== undefined) {\n      var type = fieldDefinition.type,\n        isRequired = fieldDefinition.isRequired,\n        name_1 = fieldDefinition.name,\n        isArray = fieldDefinition.isArray;\n      if (isRequired && (v === null || v === undefined)) {\n        throw new Error(\"Field \" + name_1 + \" is required\");\n      }\n      if (isGraphQLScalarType(type)) {\n        var jsType_1 = GraphQLScalarType.getJSType(type);\n        if (isArray) {\n          if (!Array.isArray(v)) {\n            throw new Error(\"Field \" + name_1 + \" should be of type \" + jsType_1 + \"[], \" + typeof v + \" received. \" + v);\n          }\n          if (v.some(function (e) {\n            return typeof e !== jsType_1;\n          })) {\n            var elemTypes = v.map(function (e) {\n              return typeof e;\n            }).join(',');\n            throw new Error(\"All elements in the \" + name_1 + \" array should be of type \" + jsType_1 + \", [\" + elemTypes + \"] received. \" + v);\n          }\n        } else if (typeof v !== jsType_1 && v !== null) {\n          throw new Error(\"Field \" + name_1 + \" should be of type \" + jsType_1 + \", \" + typeof v + \" received. \" + v);\n        }\n      }\n    }\n    draft[k] = v;\n  });\n};\nvar createModelClass = function (modelDefinition) {\n  var clazz = /** @class */function () {\n    function Model(init) {\n      var instance = produce(this, function (draft) {\n        initializeInstance(init, modelDefinition, draft);\n        var modelInstanceMetadata = instancesMetadata.has(init) ? init : {};\n        var _id = modelInstanceMetadata.id,\n          _version = modelInstanceMetadata._version,\n          _lastChangedAt = modelInstanceMetadata._lastChangedAt,\n          _deleted = modelInstanceMetadata._deleted;\n        var id =\n        // instancesIds is set by modelInstanceCreator, it is accessible only internally\n        _id !== null && _id !== undefined ? _id : modelDefinition.syncable ? uuid4() :\n        // Transform UUID v1 into a lexicographically sortable string for non-syncable models\n        uuid1().replace(/^(.{8})-(.{4})-(.{4})/, '$3-$2-$1');\n        draft.id = id;\n        if (modelDefinition.syncable) {\n          draft._version = _version;\n          draft._lastChangedAt = _lastChangedAt;\n          draft._deleted = _deleted;\n        }\n      });\n      return instance;\n    }\n    Model.copyOf = function (source, fn) {\n      var modelConstructor = Object.getPrototypeOf(source || {}).constructor;\n      if (!isValidModelConstructor(modelConstructor)) {\n        var msg = 'The source object is not a valid model';\n        logger.error(msg, {\n          source: source\n        });\n        throw new Error(msg);\n      }\n      return produce(source, function (draft) {\n        fn(draft);\n        draft.id = source.id;\n      });\n    };\n    return Model;\n  }();\n  clazz[immerable] = true;\n  Object.defineProperty(clazz, 'name', {\n    value: modelDefinition.name\n  });\n  return clazz;\n};\nvar createNonModelClass = function (typeDefinition) {\n  var clazz = /** @class */function () {\n    function Model(init) {\n      var instance = produce(this, function (draft) {\n        initializeInstance(init, typeDefinition, draft);\n      });\n      return instance;\n    }\n    return Model;\n  }();\n  clazz[immerable] = true;\n  Object.defineProperty(clazz, 'name', {\n    value: typeDefinition.name\n  });\n  return clazz;\n};\nvar save = function (model, condition) {\n  return __awaiter(void 0, void 0, void 0, function () {\n    var modelConstructor, msg, modelDefinition, producedCondition, savedModel;\n    return __generator(this, function (_a) {\n      switch (_a.label) {\n        case 0:\n          return [4 /*yield*/, start()];\n        case 1:\n          _a.sent();\n          modelConstructor = model ? model.constructor : undefined;\n          if (!isValidModelConstructor(modelConstructor)) {\n            msg = 'Object is not an instance of a valid model';\n            logger.error(msg, {\n              model: model\n            });\n            throw new Error(msg);\n          }\n          modelDefinition = getModelDefinition(modelConstructor);\n          producedCondition = ModelPredicateCreator.createFromExisting(modelDefinition, condition);\n          return [4 /*yield*/, storage.runExclusive(function (s) {\n            return __awaiter(void 0, void 0, void 0, function () {\n              return __generator(this, function (_a) {\n                switch (_a.label) {\n                  case 0:\n                    return [4 /*yield*/, s.save(model, producedCondition)];\n                  case 1:\n                    _a.sent();\n                    return [2 /*return*/, s.query(modelConstructor, ModelPredicateCreator.createForId(modelDefinition, model.id))];\n                }\n              });\n            });\n          })];\n        case 2:\n          savedModel = _a.sent()[0];\n          return [2 /*return*/, savedModel];\n      }\n    });\n  });\n};\nvar remove = function (modelOrConstructor, idOrCriteria) {\n  return __awaiter(void 0, void 0, void 0, function () {\n    var condition, msg, modelConstructor, msg, msg, deleted, model, modelConstructor, msg, modelDefinition, idPredicate, msg, deleted;\n    return __generator(this, function (_a) {\n      switch (_a.label) {\n        case 0:\n          return [4 /*yield*/, start()];\n        case 1:\n          _a.sent();\n          if (!modelOrConstructor) {\n            msg = 'Model or Model Constructor required';\n            logger.error(msg, {\n              modelOrConstructor: modelOrConstructor\n            });\n            throw new Error(msg);\n          }\n          if (!isValidModelConstructor(modelOrConstructor)) return [3 /*break*/, 3];\n          modelConstructor = modelOrConstructor;\n          if (!idOrCriteria) {\n            msg = 'Id to delete or criteria required. Do you want to delete all? Pass Predicates.ALL';\n            logger.error(msg, {\n              idOrCriteria: idOrCriteria\n            });\n            throw new Error(msg);\n          }\n          if (typeof idOrCriteria === 'string') {\n            condition = ModelPredicateCreator.createForId(getModelDefinition(modelConstructor), idOrCriteria);\n          } else {\n            condition = ModelPredicateCreator.createFromExisting(getModelDefinition(modelConstructor),\n            /**\n             * idOrCriteria is always a ProducerModelPredicate<T>, never a symbol.\n             * The symbol is used only for typing purposes. e.g. see Predicates.ALL\n             */\n            idOrCriteria);\n            if (!condition || !ModelPredicateCreator.isValidPredicate(condition)) {\n              msg = 'Criteria required. Do you want to delete all? Pass Predicates.ALL';\n              logger.error(msg, {\n                condition: condition\n              });\n              throw new Error(msg);\n            }\n          }\n          return [4 /*yield*/, storage.delete(modelConstructor, condition)];\n        case 2:\n          deleted = _a.sent()[0];\n          return [2 /*return*/, deleted];\n        case 3:\n          model = modelOrConstructor;\n          modelConstructor = Object.getPrototypeOf(model || {}).constructor;\n          if (!isValidModelConstructor(modelConstructor)) {\n            msg = 'Object is not an instance of a valid model';\n            logger.error(msg, {\n              model: model\n            });\n            throw new Error(msg);\n          }\n          modelDefinition = getModelDefinition(modelConstructor);\n          idPredicate = ModelPredicateCreator.createForId(modelDefinition, model.id);\n          if (idOrCriteria) {\n            if (typeof idOrCriteria !== 'function') {\n              msg = 'Invalid criteria';\n              logger.error(msg, {\n                idOrCriteria: idOrCriteria\n              });\n              throw new Error(msg);\n            }\n            condition = idOrCriteria(idPredicate);\n          } else {\n            condition = idPredicate;\n          }\n          return [4 /*yield*/, storage.delete(model, condition)];\n        case 4:\n          deleted = _a.sent()[0][0];\n          return [2 /*return*/, deleted];\n      }\n    });\n  });\n};\nvar observe = function (modelConstructor, idOrCriteria) {\n  var predicate;\n  if (idOrCriteria !== undefined && modelConstructor === undefined) {\n    var msg = 'Cannot provide criteria without a modelConstructor';\n    logger.error(msg, idOrCriteria);\n    throw new Error(msg);\n  }\n  if (modelConstructor && !isValidModelConstructor(modelConstructor)) {\n    var msg = 'Constructor is not for a valid model';\n    logger.error(msg, {\n      modelConstructor: modelConstructor\n    });\n    throw new Error(msg);\n  }\n  if (typeof idOrCriteria === 'string') {\n    predicate = ModelPredicateCreator.createForId(getModelDefinition(modelConstructor), idOrCriteria);\n  } else {\n    predicate = modelConstructor && ModelPredicateCreator.createFromExisting(getModelDefinition(modelConstructor), idOrCriteria);\n  }\n  return new Observable(function (observer) {\n    var handle;\n    (function () {\n      return __awaiter(void 0, void 0, void 0, function () {\n        return __generator(this, function (_a) {\n          switch (_a.label) {\n            case 0:\n              return [4 /*yield*/, start()];\n            case 1:\n              _a.sent();\n              handle = storage.observe(modelConstructor, predicate).filter(function (_a) {\n                var model = _a.model;\n                return namespaceResolver(model) === USER;\n              }).subscribe(observer);\n              return [2 /*return*/];\n          }\n        });\n      });\n    })();\n\n    return function () {\n      if (handle) {\n        handle.unsubscribe();\n      }\n    };\n  });\n};\nvar query = function (modelConstructor, idOrCriteria, pagination) {\n  return __awaiter(void 0, void 0, void 0, function () {\n    var msg, predicate_1, result, criteria, predicate, _a, limit, page;\n    return __generator(this, function (_b) {\n      switch (_b.label) {\n        case 0:\n          return [4 /*yield*/, start()];\n        case 1:\n          _b.sent();\n          if (!isValidModelConstructor(modelConstructor)) {\n            msg = 'Constructor is not for a valid model';\n            logger.error(msg, {\n              modelConstructor: modelConstructor\n            });\n            throw new Error(msg);\n          }\n          if (!(typeof idOrCriteria === 'string')) return [3 /*break*/, 3];\n          if (pagination !== undefined) {\n            logger.warn('Pagination is ignored when querying by id');\n          }\n          predicate_1 = ModelPredicateCreator.createForId(getModelDefinition(modelConstructor), idOrCriteria);\n          return [4 /*yield*/, storage.query(modelConstructor, predicate_1)];\n        case 2:\n          result = _b.sent()[0];\n          if (result) {\n            return [2 /*return*/, result];\n          }\n          return [2 /*return*/, undefined];\n        case 3:\n          criteria = idOrCriteria;\n          predicate = !isPredicatesAll(criteria) ? ModelPredicateCreator.createFromExisting(getModelDefinition(modelConstructor), criteria) : undefined;\n          _a = pagination || {}, limit = _a.limit, page = _a.page;\n          if (page !== undefined && limit === undefined) {\n            throw new Error('Limit is required when requesting a page');\n          }\n          if (page !== undefined) {\n            if (typeof page !== 'number') {\n              throw new Error('Page should be a number');\n            }\n            if (page < 0) {\n              throw new Error(\"Page can't be negative\");\n            }\n          }\n          if (limit !== undefined) {\n            if (typeof limit !== 'number') {\n              throw new Error('Limit should be a number');\n            }\n            if (limit < 0) {\n              throw new Error(\"Limit can't be negative\");\n            }\n          }\n          return [2 /*return*/, storage.query(modelConstructor, predicate, pagination)];\n      }\n    });\n  });\n};\nvar sync;\nvar amplifyConfig = {};\nvar conflictHandler;\nvar errorHandler;\nvar maxRecordsToSync;\nvar syncPageSize;\nvar fullSyncInterval;\nfunction configure(config) {\n  if (config === void 0) {\n    config = {};\n  }\n  var configDataStore = config.DataStore,\n    configConflictHandler = config.conflictHandler,\n    configErrorHandler = config.errorHandler,\n    configMaxRecordsToSync = config.maxRecordsToSync,\n    configSyncPageSize = config.syncPageSize,\n    configFullSyncInterval = config.fullSyncInterval,\n    configFromAmplify = __rest(config, [\"DataStore\", \"conflictHandler\", \"errorHandler\", \"maxRecordsToSync\", \"syncPageSize\", \"fullSyncInterval\"]);\n  amplifyConfig = __assign(__assign({}, configFromAmplify), amplifyConfig);\n  conflictHandler = configDataStore && configDataStore.conflictHandler || conflictHandler || config.conflictHandler || defaultConflictHandler;\n  errorHandler = configDataStore && configDataStore.errorHandler || errorHandler || config.errorHandler || defaultErrorHandler;\n  maxRecordsToSync = configDataStore && configDataStore.maxRecordsToSync || maxRecordsToSync || config.maxRecordsToSync;\n  syncPageSize = configDataStore && configDataStore.syncPageSize || syncPageSize || config.syncPageSize;\n  fullSyncInterval = configDataStore && configDataStore.fullSyncInterval || configFullSyncInterval || config.fullSyncInterval || 24 * 60; // 1 day\n}\n\nfunction defaultConflictHandler(conflictData) {\n  var localModel = conflictData.localModel,\n    modelConstructor = conflictData.modelConstructor,\n    remoteModel = conflictData.remoteModel;\n  var _version = remoteModel._version;\n  return modelInstanceCreator(modelConstructor, __assign(__assign({}, localModel), {\n    _version: _version\n  }));\n}\nfunction defaultErrorHandler(error) {\n  logger.warn(error);\n}\nfunction getModelConstructorByModelName(namespaceName, modelName) {\n  var result;\n  switch (namespaceName) {\n    case DATASTORE:\n      result = dataStoreClasses[modelName];\n      break;\n    case USER:\n      result = userClasses[modelName];\n      break;\n    case SYNC:\n      result = syncClasses[modelName];\n      break;\n    case STORAGE:\n      result = storageClasses[modelName];\n      break;\n    default:\n      exhaustiveCheck(namespaceName);\n      break;\n  }\n  if (isValidModelConstructor(result)) {\n    return result;\n  } else {\n    var msg = \"Model name is not valid for namespace. modelName: \" + modelName + \", namespace: \" + namespaceName;\n    logger.error(msg);\n    throw new Error(msg);\n  }\n}\nfunction checkSchemaVersion(storage, version) {\n  return __awaiter(this, void 0, void 0, function () {\n    var Setting, modelDefinition;\n    var _this = this;\n    return __generator(this, function (_a) {\n      switch (_a.label) {\n        case 0:\n          Setting = dataStoreClasses.Setting;\n          modelDefinition = schema.namespaces[DATASTORE].models.Setting;\n          return [4 /*yield*/, storage.runExclusive(function (s) {\n            return __awaiter(_this, void 0, void 0, function () {\n              var schemaVersionSetting, storedValue;\n              return __generator(this, function (_a) {\n                switch (_a.label) {\n                  case 0:\n                    return [4 /*yield*/, s.query(Setting, ModelPredicateCreator.createFromExisting(modelDefinition, function (c) {\n                      return c.key('eq', SETTING_SCHEMA_VERSION);\n                    }))];\n                  case 1:\n                    schemaVersionSetting = _a.sent()[0];\n                    if (!(schemaVersionSetting !== undefined)) return [3 /*break*/, 4];\n                    storedValue = JSON.parse(schemaVersionSetting.value);\n                    if (!(storedValue !== version)) return [3 /*break*/, 3];\n                    return [4 /*yield*/, s.clear(false)];\n                  case 2:\n                    _a.sent();\n                    _a.label = 3;\n                  case 3:\n                    return [3 /*break*/, 6];\n                  case 4:\n                    return [4 /*yield*/, s.save(modelInstanceCreator(Setting, {\n                      key: SETTING_SCHEMA_VERSION,\n                      value: JSON.stringify(version)\n                    }))];\n                  case 5:\n                    _a.sent();\n                    _a.label = 6;\n                  case 6:\n                    return [2 /*return*/];\n                }\n              });\n            });\n          })];\n\n        case 1:\n          _a.sent();\n          return [2 /*return*/];\n      }\n    });\n  });\n}\n\nvar syncSubscription;\nvar initResolve;\nvar initialized;\nfunction start() {\n  return __awaiter(this, void 0, void 0, function () {\n    var aws_appsync_graphqlEndpoint, fullSyncIntervalInMilliseconds;\n    return __generator(this, function (_a) {\n      switch (_a.label) {\n        case 0:\n          if (!(initialized === undefined)) return [3 /*break*/, 1];\n          initialized = new Promise(function (res) {\n            initResolve = res;\n          });\n          return [3 /*break*/, 3];\n        case 1:\n          return [4 /*yield*/, initialized];\n        case 2:\n          _a.sent();\n          return [2 /*return*/];\n        case 3:\n          storage = new Storage(schema, namespaceResolver, getModelConstructorByModelName, modelInstanceCreator);\n          return [4 /*yield*/, checkSchemaVersion(storage, schema.version)];\n        case 4:\n          _a.sent();\n          aws_appsync_graphqlEndpoint = amplifyConfig.aws_appsync_graphqlEndpoint;\n          if (aws_appsync_graphqlEndpoint) {\n            sync = new SyncEngine(schema, namespaceResolver, syncClasses, userClasses, storage, modelInstanceCreator, maxRecordsToSync, syncPageSize, conflictHandler, errorHandler);\n            fullSyncIntervalInMilliseconds = fullSyncInterval * 1000 * 60;\n            syncSubscription = sync.start({\n              fullSyncInterval: fullSyncIntervalInMilliseconds\n            }).subscribe({\n              error: function (err) {\n                logger.warn('Sync error', err);\n              }\n            });\n          }\n          initResolve();\n          return [2 /*return*/];\n      }\n    });\n  });\n}\n\nfunction clear() {\n  return __awaiter(this, void 0, void 0, function () {\n    return __generator(this, function (_a) {\n      switch (_a.label) {\n        case 0:\n          if (storage === undefined) {\n            return [2 /*return*/];\n          }\n\n          if (syncSubscription && !syncSubscription.closed) {\n            syncSubscription.unsubscribe();\n          }\n          return [4 /*yield*/, storage.clear()];\n        case 1:\n          _a.sent();\n          initialized = undefined; // Should re-initialize when start() is called.\n          storage = undefined;\n          sync = undefined;\n          return [2 /*return*/];\n      }\n    });\n  });\n}\n\nfunction getNamespace() {\n  var namespace = {\n    name: DATASTORE,\n    relationships: {},\n    enums: {},\n    nonModels: {},\n    models: {\n      Setting: {\n        name: 'Setting',\n        pluralName: 'Settings',\n        syncable: false,\n        fields: {\n          id: {\n            name: 'id',\n            type: 'ID',\n            isRequired: true,\n            isArray: false\n          },\n          key: {\n            name: 'key',\n            type: 'String',\n            isRequired: true,\n            isArray: false\n          },\n          value: {\n            name: 'value',\n            type: 'String',\n            isRequired: true,\n            isArray: false\n          }\n        }\n      }\n    }\n  };\n  return namespace;\n}\nvar DataStore = /** @class */function () {\n  function DataStore() {}\n  DataStore.getModuleName = function () {\n    return 'DataStore';\n  };\n  DataStore.query = query;\n  DataStore.save = save;\n  DataStore.delete = remove;\n  DataStore.observe = observe;\n  DataStore.configure = configure;\n  DataStore.clear = clear;\n  return DataStore;\n}();\nexport { initSchema, DataStore };","map":null,"metadata":{},"sourceType":"module"}